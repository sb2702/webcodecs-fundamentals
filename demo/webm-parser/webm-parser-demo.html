<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebM Parser Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/ts-ebml@3.0.2/dist/EBML.min.js"></script>





</head>
<body>
  <h1>WebM Parser Demo</h1>
  <p>Upload a WebM file to parse its metadata and extract encoded chunks.</p>


  <canvas width="320" height="180" id="canvas"></canvas>

  <script>

    console.log("ebml", EBML)


    const decoder = new EBML.Decoder();

    console.log("Decoder", decoder)

    function readVInt(data, offset) {
      const firstByte = data[offset];

      // Find the VINT_MARKER (first 1 bit) to determine the size
      let size = 1;
      let mask = 0x80;
      while (size <= 8 && (firstByte & mask) === 0) {
        size++;
        mask >>= 1;
      }

      if (size > 8) {
        throw new Error('Invalid VINT at offset ' + offset);
      }

      // Extract data bits from first byte (remove the VINT_MARKER bit)
      let value = firstByte & (mask - 1);

      // Read remaining bytes
      for (let i = 1; i < size; i++) {
        value = (value << 8) | data[offset + i];
      }

      return { value, size };

    }



    
    async function decode(chunks, desc){


      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');


      const decoder = new VideoDecoder({
        output: function(frame){

      

          ctx.drawImage(frame, 0, 0)
          frame.close();
        },
        error: function(e){console.log(e)}
      })


      decoder.configure({

        codec: 'vp09.00.10.08',
        description: desc
      })

      for(chunk of chunks){


        decoder.decode(chunk)
      }



    }

    

    function parseWebMFile(buffer) {
      const data = new Uint8Array(buffer);
      const ebmlElms = decoder.decode(buffer);




      console.log(ebmlElms)


      const tracks = getTrackInfo(ebmlElms);

      console.log(`Tracks`, tracks)

      const chunks = getChunks(ebmlElms);

      console.log("Chunks", chunks)



      const desc = getDescription(ebmlElms)



      decode(chunks, desc);


      


      

    }

    function getTrackInfo(ebmlElms) {
        const tracks = [];

        for (let i = 0; i < ebmlElms.length; i++) {
          const el = ebmlElms[i];

          if (el.name === 'TrackEntry') {
            const track = {};

            // Find elements within this track entry
            for (let j = i + 1; j < ebmlElms.length; j++) {
              const trackEl = ebmlElms[j];

              // Stop when we hit another TrackEntry or leave the track scope
              if (trackEl.name === 'TrackEntry') break;

              if (trackEl.name === 'TrackNumber') {
                track.trackNumber = trackEl.value;
              } else if (trackEl.name === 'CodecID') {
                track.codecId = trackEl.value;
              } else if (trackEl.name === 'TrackType') {
                track.trackType = trackEl.value; // 1=video, 2=audio
              } else if (trackEl.name === 'CodecPrivate') {
                track.codecPrivate = trackEl.data; // Configuration data for decoder
              }
            }

            tracks.push(track);
          }
        }

      return tracks;
  }


    function getDescription(ebmlElms){

      for(let i=0; i< ebmlElms.length; i++){
        const elI = ebmlElms[i];

        if(elI.name === 'CodecPrivate'){

          return elI.value;
        }

      }

    }


    function getChunks(ebmlElms){

      const chunks = [];
   
      for(let i=0; i< ebmlElms.length; i++){
        const elI = ebmlElms[i];

        if(elI.name !== 'Cluster') continue;

        const cluster = elI;
        console.log(`Cluster`, cluster);

        let tsEl;
        let k;

        for (let j =i; j < ebmlElms.length; j++){

          const elJ = ebmlElms[j];

          if(elJ.name === 'Timestamp'){
            tsEl = elJ;
            k = j;
            break;
          }
        }

        console.log(`TS El`, tsEl);


        



        if(tsEl && k){

          const tsOffset = tsEl.value;

          for (let j =(k+1); j < ebmlElms.length; j++){

            const elJ = ebmlElms[j];

            if(elJ.name !== 'SimpleBlock'){
              break;
            }

            const block = elJ;

            const data = new Uint8Array(block.data);
            let offset = 0;

            // Read track number (VINT)
            const { value: trackNum, size } = readVInt(data, offset);
            offset += size;

            // Read relative timestamp (int16, big-endian)
            const relativeTs = (data[offset] << 8) | data[offset + 1];
            offset += 2;

            // Read flags
            const flags = data[offset];
            offset += 1;

            const isKeyframe = (flags & 0x80) !== 0;



            // Extract frame data
            const frameData = data.slice(offset);
            const blockTimestamp = relativeTs +tsOffset;


            if(trackNum === 2){


            } else if (trackNum == 1){


              const chunk = new EncodedVideoChunk({

                type: isKeyframe? "key" : "delta",
                timestamp: blockTimestamp*1e3,
                data: frameData,
                duration: 42*1e3
              })





              chunks.push(chunk)

      


            }







          }


        }


      }




      return chunks;

    }


    fetch('hero-small.webm').then(async function(file){

      const buffer = await file.arrayBuffer();

      console.log("Buffer", buffer)

      parseWebMFile(buffer)


    })



  </script>
</body>
</html>
