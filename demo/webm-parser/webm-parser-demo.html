<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebM Parser Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/ts-ebml@3.0.2/dist/EBML.min.js"></script>



</head>
<body>
  <h1>WebM Parser Demo</h1>
  <p>Upload a WebM file to parse its metadata and extract encoded chunks.</p>



  <script>

    console.log("ebml", EBML)


    const decoder = new EBML.Decoder();

    console.log("Decoder", decoder)

    function readVInt(data, offset) {
      const firstByte = data[offset];

      // Find the VINT_MARKER (first 1 bit) to determine the size
      let size = 1;
      let mask = 0x80;
      while (size <= 8 && (firstByte & mask) === 0) {
        size++;
        mask >>= 1;
      }

      if (size > 8) {
        throw new Error('Invalid VINT at offset ' + offset);
      }

      // Extract data bits from first byte (remove the VINT_MARKER bit)
      let value = firstByte & (mask - 1);

      // Read remaining bytes
      for (let i = 1; i < size; i++) {
        value = (value << 8) | data[offset + i];
      }

      return { value, size };
    }

    function parseWebMFile(buffer) {
      const data = new Uint8Array(buffer);
      const ebmlElms = decoder.decode(buffer);




      console.log(ebmlElms)

      const chunks = getChunks(ebmlElms);

      console.log("Chunks", chunks)



      


      

    }


    function getChunks(ebmlElms){

      const chunks = [];
   
      for(let i=0; i< ebmlElms.length; i++){
        const elI = ebmlElms[i];

        if(elI.name !== 'Cluster') continue;

        const cluster = elI;
        console.log(`Cluster`, cluster);

        let tsEl;
        let k;

        for (let j =i; j < ebmlElms.length; j++){

          const elJ = ebmlElms[j];

          if(elJ.name === 'Timestamp'){
            tsEl = elJ;
            k = j;
            break;
          }
        }

        console.log(`TS El`, tsEl);


        



        if(tsEl && k){

          const tsOffset = tsEl.value;

          for (let j =(k+1); j < ebmlElms.length; j++){

            const elJ = ebmlElms[j];

            if(elJ.name !== 'SimpleBlock'){
              break;
            }

            const block = elJ;

            const data = new Uint8Array(block.data);
            let offset = 0;

            // Read track number (VINT)
            const { value: trackNum, size } = readVInt(data, offset);
            offset += size;

            // Read relative timestamp (int16, big-endian)
            const relativeTs = (data[offset] << 8) | data[offset + 1];
            offset += 2;

            // Read flags
            const flags = data[offset];
            offset += 1;

            const isKeyframe = (flags & 0x80) !== 0;



            // Extract frame data
            const frameData = data.slice(offset);
            const blockTimestamp = relativeTs +tsOffset;


            if(trackNum === 2){


            } else if (trackNum == 1){


              const chunk = new EncodedVideoChunk({

                type: isKeyframe? "key" : "delta",
                timestamp: blockTimestamp*1e3,
                data,
                duration: 42*1e3
              })


              console.log("Block data", block.data);
              console.log("Block timestamp", blockTimestamp)



              chunks.push(chunk)

      


            }







          }


        }


      }




/*
      for (const cluster of clusters) {

        console.log("Cluster", cluster);
        // Find cluster timestamp
        const tsEl = ebmlElms.find(el =>
          el.name === 'Timestamp' &&
          el.offset > cluster.offset &&
          el.offset < cluster.offset + cluster.dataSize
        );

        console.log("TS el", tsEl)
        const clusterTimestamp = tsEl ? tsEl.value : 0;

        // Find SimpleBlocks in this cluster
        const blocks = ebmlElms.filter(el =>
          (el.name === 'SimpleBlock' || el.name === 'Block') &&
          el.offset > cluster.offset &&
          el.offset < cluster.offset + cluster.dataSize
        );

        for (const block of blocks) {
          // Parse block.data (Uint8Array)
          const data = new Uint8Array(block.data);
          let offset = 0;

          // Read track number (VINT)
          const { value: trackNum, size } = readVInt(data, offset);
          offset += size;

          // Read relative timestamp (int16, big-endian)
          const relativeTs = (data[offset] << 8) | data[offset + 1];
          offset += 2;

          // Read flags
          const flags = data[offset];
          offset += 1;

          const isKeyframe = (flags & 0x80) !== 0;

          // Extract frame data
          const frameData = data.slice(offset);

          chunks.push({
            trackNumber: trackNum,
            timestamp: clusterTimestamp + relativeTs,
            isKeyframe,
            data: frameData
          });
        }
      }
*/

      return chunks;

    }


    fetch('hero-small.webm').then(async function(file){

      const buffer = await file.arrayBuffer();

      console.log("Buffer", buffer)

      parseWebMFile(buffer)


    })



  </script>
</body>
</html>
